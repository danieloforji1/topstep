"""
Base Strategy Interface
All strategies must implement this interface for unified backtesting
"""
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
from datetime import datetime
import pandas as pd


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    timestamp: datetime
    direction: str  # "LONG", "SHORT", or "FLAT"
    entry_price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: float = 1.0  # 0.0 to 1.0
    metadata: Dict[str, Any] = None  # Strategy-specific data
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class ExitReason:
    """Reason for exiting a position"""
    reason: str  # "STOP_LOSS", "TAKE_PROFIT", "SIGNAL_REVERSAL", "TIME_STOP", etc.
    timestamp: datetime
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class MarketData:
    """Normalized market data for strategy processing"""
    timestamp: datetime
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    bid: Optional[float] = None
    ask: Optional[float] = None
    bid_volume: Optional[float] = None
    ask_volume: Optional[float] = None
    
    # Multi-timeframe data (optional)
    higher_timeframe_data: Optional[pd.DataFrame] = None
    
    # Multiple instruments (optional)
    correlated_data: Optional[Dict[str, 'MarketData']] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must implement:
    - generate_signal(): Generate trading signals from market data
    - calculate_position_size(): Determine position size based on risk
    - check_exit(): Determine if position should be exited
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize strategy with configuration
        
        Args:
            config: Strategy-specific configuration parameters
        """
        self.config = config
        self.name = self.__class__.__name__
    
    @abstractmethod
    def get_required_data(self) -> List[str]:
        """
        Return list of required data types
        
        Returns:
            List of strings like ["OHLCV", "bid_ask", "multiple_instruments", etc.]
        """
        pass
    
    @abstractmethod
    def generate_signal(
        self,
        market_data: MarketData,
        historical_data: pd.DataFrame,
        current_position: Optional[Any] = None
    ) -> Optional[Signal]:
        """
        Generate trading signal from market data
        
        Args:
            market_data: Current market data point
            historical_data: Historical OHLCV DataFrame
            current_position: Current position (if any)
            
        Returns:
            Signal object or None if no signal
        """
        pass
    
    @abstractmethod
    def calculate_position_size(
        self,
        signal: Signal,
        account_equity: float,
        market_data: MarketData,
        historical_data: pd.DataFrame
    ) -> int:
        """
        Calculate position size based on risk management
        
        Args:
            signal: Trading signal
            account_equity: Current account equity
            market_data: Current market data
            historical_data: Historical data for volatility calculation
            
        Returns:
            Number of contracts to trade
        """
        pass
    
    @abstractmethod
    def check_exit(
        self,
        position: Any,
        market_data: MarketData,
        historical_data: pd.DataFrame
    ) -> Optional[ExitReason]:
        """
        Check if position should be exited
        
        Args:
            position: Current position object
            market_data: Current market data
            historical_data: Historical data
            
        Returns:
            ExitReason if should exit, None otherwise
        """
        pass
    
    def on_bar(self, market_data: MarketData, historical_data: pd.DataFrame):
        """
        Called on each new bar (optional override for state management)
        
        Args:
            market_data: Current market data
            historical_data: Historical data
        """
        pass
    
    def reset(self):
        """
        Reset strategy state (called at start of backtest)
        """
        pass
    
    def get_state(self) -> Dict[str, Any]:
        """
        Get current strategy state (for debugging/monitoring)
        
        Returns:
            Dictionary of strategy state
        """
        return {}

