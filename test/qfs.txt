# Quant Futures Strategies: Cross-Asset Statistical Arbitrage & Multi-Factor Intraday Model

This document provides complete, production-level strategy build files for two institutional-grade futures trading systems:

1. **Cross-Asset Statistical Arbitrage (StatArb)**
2. **Multi-Factor Intraday Model**

Both strategies are designed for **TopStep funded accounts**, integrate cleanly with your existing Python execution engine, and fully utilize your current TopStep data access and automation stack.

---

# 1. Cross-Asset Statistical Arbitrage (StatArb)

## 1.1 Strategy Overview

Cross-Asset StatArb exploits price relationships between two correlated futures markets.

### Ideal Pairs

* MGC ↔ GC (micro/full gold)
* MNQ ↔ MES (micro Nasdaq ↔ micro S&P)
* ES ↔ NQ
* GC ↔ DX (inverse correlation)
* ES ↔ ZB (yields lead equity)

This document builds the **MGC ↔ GC** version but can be swapped for any pair.

---

## 1.2 Alpha Sources

The strategy pulls alpha from three quant-proven mechanisms:

### **1. Cointegration**

The spread between two related futures converges back to equilibrium.

### **2. Lead-Lag Behavior**

One product reacts faster to order flow than the other.

### **3. Correlation Breakdown/Reversion**

Temporary dislocations revert rapidly.

---

## 1.3 Data Requirements

From TopStep data API:

* Bid/ask prices
* Trades
* 1-second or 50–200ms bars (depending on your plan)
* Volume
* Book pressure (optional)

---

## 1.4 Mathematical Model

### Step 1: Compute Spread

```
spread = price_A - beta * price_B
```

Where **beta** is hedge ratio.

### Step 2: Normalize Spread

```
zscore = (spread - mean(spread)) / std(spread)
```

### Step 3: Signal

```
if zscore > +Zentry: short spread (short A, long B)
if zscore < -Zentry: long spread (long A, short B)
```

### Step 4: Exit

```
exit when |zscore| < Zexit
```

---

## 1.5 Trading Rules

### Entry

* Z-entry = ±2.0
* Max spread deviation lookback = 1–3 days intraday

### Exit

* Z-exit = 0.5–0.8

### Stop Loss

* Spread stop = 3 std deviations
* Time stop = 30 min–2 hours

### Position Sizing

Risk per trade: 0.5–1.0% of account

Use volatility-based sizing:

```
position = k * (account_risk / volatility_spread)
```

---

## 1.6 Execution Logic

1. Monitor tick data for both markets.
2. Compute mid-price for both.
3. Calculate spread + z-score in realtime.
4. When signal triggers:

   * Send both legs simultaneously.
5. Auto-hedge if one leg slips.
6. Log PnL from spread, not indiv. legs.

---

## 1.7 Pseudocode (Python)

```
while True:
    pA = mid(GC)
    pB = mid(MGC)

    spread = pA - beta * pB
    z = (spread - mu) / sigma

    if z > 2:
        short(GC)
        long(MGC)
    elif z < -2:
        long(GC)
        short(MGC)

    if abs(z) < 0.6:
        close_all()
```

---

## 1.8 Backtesting Setup (TopStep Data)

* Pull 2024–2025 data
* Use 1-second bars
* Compute rolling mean/std every day
* Test on multiple volatility regimes

Metrics to collect:

* Sharpe
* Sortino
* Win rate
* Max DD
* Avg hold time
* Avg profit per trade

---

# 2. Multi-Factor Intraday Futures Model

## 2.1 Strategy Overview

This model blends multiple weak predictive signals into a strong composite signal.

This is identical to what Two Sigma, Citadel, AQR do.

Works best for:

* ES, NQ, MES, MNQ
* GC, MGC
* CL

You already have two strategies running; this will be super easy to integrate.

---

## 2.2 Factor Groups

The system uses 5 categories of factors.

### **1. Momentum Factors**

* 1–5 min trend slope
* Volume-confirmed breakouts
* Range expansion

### **2. Mean Reversion Factors**

* VWAP deviation
* RSI(2–6)
* Micro double tops/bottoms

### **3. Volatility Factors**

* ATR expansion
* Historical vol compression (Squeeze)

### **4. Order Flow Factors**

* Bid/ask imbalance
* Aggressive order streak detection
* Absorption events

### **5. Seasonality Factors**

* London Open behavior
* NY open breakout/reversion signatures
* Time-of-day volatility curve

---

## 2.3 Scoring Engine

Each factor outputs a score between –1 and +1.

The final model prediction is:

```
score = w1*mom + w2*meanrev + w3*vol + w4*orderflow + w5*seasonality
```

---

## 2.4 Execution Rules

### Long Entry

```
score > +S
trend aligned
volatility in normal range
```

### Short Entry

```
score < -S
trend aligned
```

### Exit

```
score crosses 0
OR
hit profit target
OR
hit stop
```

### Stop/Target

* Stop = 1.5× ATR
* Target = 1.2–2.0× ATR

---

## 2.5 Position Sizing

Volatility-based:

```
size = risk_per_trade / ATR
```

---

## 2.6 Pseudocode

```
while trading_hours():
    factors = compute_factors(market)
    score = dot(weights, factors)

    if score > 0.6:
        long()
    elif score < -0.6:
        short()

    if score crosses zero or stop hit:
        close()
```

---

## 2.7 Backtesting Plan (TopStep Data)

* Use 1-min bar data
* Compute all factor values
* Optimize factor weights
* Run walk-forward tests
* Compare model performance daily/weekly

Metrics:

* Sharpe
* Annualized return
* Max DD
* Avg profit per trade
* Stability over time-of-day

---

# 3. Deployment Into TopStep Live Trading

Both strategies integrate like this:

1. Data comes from TopStep feed
2. Strategies compute signals in real-time
3. Executor submits trades to Rithmic/Tradovate (depending on your setup)
4. Logs stored locally + cloud
5. Daily report generated

---

# 4. Next Steps

I can:

* Add full production Python code
* Build backtest scripts
* Add visualization charts
* Implement real-time Discord alerts
* Build a Docker container deployment

Tell me which strategy to finalize with code first.
